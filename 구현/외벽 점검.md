## 날짜
2021-06-30 ~ 2021-07-01

<br>

## 문제 (2020 카카오 신입 공채)
https://programmers.co.kr/learn/courses/30/lessons/60062

<br>

## 문제 유형
**그리디 + 완전 탐색+ 구현** or 순열 + 완전 탐색 + 구현

<br>

## Code

### 순열을 사용하는 코드

```python
from itertools import permutations

def find_answer(weak, length, current_dist):
    weak_len = len(weak) // 2
    current_answer = length + 1
    
    for start in range(weak_len):
        count = 1
        limit = weak[start] + current_dist[0][1]
        for i in range(start, start + weak_len):
            if weak[i] > limit:
                count += 1
                limit = weak[i] + current_dist[count - 1][1]
                
                if count > length:
                    break
                    
        current_answer = min(current_answer, count)
        
    return current_answer

def process(weak, dist, length, cnt, current_dist):
    answer = length + 1
    
    if cnt == length:
        return find_answer(weak, length, current_dist)

    for i, worker in enumerate(dist):
        if (i, worker) not in current_dist:
            cnt += 1
            current_dist.append((i, worker))
            answer = min(answer, process(weak, dist, length, cnt, current_dist))
            cnt -= 1
            current_dist.pop()
    
    return answer

def solution(n, weak, dist):
    weak = weak + [v + n for v in weak]
    length = len(dist)
    answer = length + 1
    
    for workers in list(permutations(dist)):
        answer = min(answer, find_answer(weak, length, workers))
    #answer = min(length + 1, process(weak, dist, length, 0, []))
    
    if answer > length:
        return -1
    return answer
```
<br>

### 그리디 알고리즘을 사용한 코드

```python
def is_possible(weak, weak_len, workers, workers_cnt):
    for start in range(weak_len):
        count = 1
        limit = weak[start] + workers[0]
        
        for i in range(start, start + weak_len):
            if weak[i] > limit:
                count += 1
                if count > workers_cnt:
                    return False
                
                limit = weak[i] + workers[count - 1]
                
        return True
    
def solution(n, weak, dist):
    weak_len = len(weak)
    weak = weak + [v + n for v in weak]
    dist_len = len(dist)
    
    
    #answer = min(length + 1, process(weak, dist, length, 0, []))
    answer = dist_len + 1
    for cnt in range(1, dist_len + 1):
        s_idx = dist_len - 1
        e_idx = s_idx - cnt
        workers = dist[s_idx : e_idx : -1]
        
        if is_possible(weak, weak_len, workers, cnt):
            answer = cnt
            break
            
    if answer > dist_len:
        return -1
    return answer
```
<br>

## 풀이


<br>

## Feedback
