## 날짜
2021-06-30 ~ 2021-07-01<br>
2021-07-05

<br>

## 문제 (2020 카카오 신입 공채)
https://programmers.co.kr/learn/courses/30/lessons/60062

<br>

## 문제 유형
1. 재귀(순열) + 완전 탐색 + 구현
2. 그리디 + 완전 탐색 + 구현 

<br>

## 풀이 <br><br>

### 1. 재귀를 사용하는 풀이 <br><br>

1. 어떻게 시계, 반시계 방향을 처리할 것인가?
2. 왜 재귀(순열)를 사용해야 하는가?

<br>

#### 1. 방향 처리 <br><br>
예제1을 분석해보자.

 n=12, weak=[1,5,6,10], dist=[1,2,3,4]일 때, dist[3]이 10m ~ 1m 지점을 시계방향으로 점검할 수 있고, 이것은 **1m ~ 10m 반시계 방향으로 점검하는 것과 같다.** 

따라서, **weak의 값들을 n씩 더해서 weak의 길이를 2배로 늘려줌으로써 원형을 선형으로 바꿔주면(***weak=[1,5,6,10,13,17,18,22]***), 10m -> 13m와 같이 양의 방향으로 시계,반시계 방향을 모두 처리를 할 수 있다.** 

<br>

#### 2. 재귀(순열) <br><br>
한 방향으로 모두 처리할 수 있다는 걸 알았지만, 어디에 누굴 보내야 최소한의 수로 점검할 수 있는지는 여전히 알 수 없다. 그러므로 우리는 모든 지점에 모든 사람을 순서대로 보내서 확인해봐야 하며, 그 순서 역시 가능한 모든 순서에 대해 확인해야 한다.

**즉, 양의 방향으로만 점검하면 되므로, 친구들을 양의 방향으로 나열할 수 있는 모든 경우를 구한다.(순열) 그리고 모든 취약 지점을 한번씩 시작 지점으로 설정하여 순서대로 점검한다.** 이 과정에서 3중 반복문이 사용된다.

위와 비슷한 방식이지만, **친구 한명을 보낼 때마다 그 친구가 커버할 수 있는 범위를 제외하고, 나머지 취약 지점과 친구들을 대상으로 외벽을 점검하는 재귀적 방식으로도 해결할 수 있다.**

<br>

### 2. 탐욕적 풀이 <br><br>
추가 예정

<br>

## Code

<br>

### 1. 재귀(순열)를 사용하는 코드

```python
# 모든 경우의 수를 얻는다
def get_all_cases(dist, length, cases, cnt, current_cases):
    # 현재 순열에 모든 친구들이 담겼으면, 전체 순열에 추가해준다
    if cnt == length:
        # list()를 사용해서 깊은 복사본을 추가,
        # 함수 종료 후 추가된 리스트가 날아가지 않도록 한다.
        cases.append(list(current_cases))
    
    # 재귀로 모든 순열을 추가한다.
    for i in range(length):
        if i not in current_cases:
            cnt += 1
            current_cases.append(i)
            get_all_cases(dist, length ,cases, cnt, current_cases)
            cnt -= 1
            current_cases.pop()

def solution(n, weak, dist):
    dist_len = len(dist)
    weak_len = len(weak)
    
    # 모든 경우의 수(순열)
    friends_cases = []
    #(친구들 거리 정보, 총 친구들 수, 모든 순열을 담을 배열, 현재 경우의 수에 담긴 친구들 수, 현재 경우의 수)
    get_all_cases(dist, dist_len, friends_cases, 0, [])
    
    answer = dist_len + 1 # 최대값 + 1로 초기화
    # 반시계 방향 해법: 외벽의 길이를 2배로 늘려서 선형으로 만든다
    # ex) 1->10 반시계 방향 점검 <--> 10 -> 13 시계 방향 점검
    new_weak = weak + [w + n for w in weak]
    
    # 모든 경우에 대해 완전탐색을 한다.
    for friends in friends_cases:
        for start in range(weak_len):
            cnt = 1
            limit = new_weak[start] + dist[friends[cnt - 1]] # 현재 친구가 검사를 시작할 취약 지점에서 최대로 갈 수 있는 지점
            
            # 모든 취약 지점을 한번씩 시작점으로 설정해서 시계방향으로 확인한다.
            for i in range(start, start + weak_len):
                if new_weak[i] > limit:
                    cnt += 1
                    if cnt > dist_len:
                        break
                        
                    limit = new_weak[i] + dist[friends[cnt - 1]]
            
            answer = min(answer, cnt)
        
    
    if answer > dist_len: # 1시간 안에 모든 지점을 검사할 수 없으면
        return -1
    return answer
```
<br>

### 2. 그리디 알고리즘을 사용한 코드

```python
def solution(n, weak, dist):
    weak_len = len(weak)
    weak = weak + [v + n for v in weak]
    dist_len = len(dist)
    dist.sort(reverse=True)
    
    repair_list = [set()]
    for cnt in range(1, dist_len+1):
        repair_time = dist[cnt-1]
        current_repairs = []
        
        for i in range(weak_len):
            limit = weak[i] + repair_time
            current_repairs.append([w % n for w in weak[i:i + weak_len] if w <= limit])
            
        combined_list = set()    
        for p_repair in repair_list:
            for c_repair in current_repairs:
                combined_repair = set(p_repair) | set(c_repair)   
                if len(combined_repair) == weak_len:
                    return cnt
                
                combined_list.add(tuple(combined_repair))
                
        repair_list = combined_list
            
    return -1
```
<br>

## Feedback
- 열심히 풀고 분석해서 사고력을 늘리자
- 순열(조합) <-> 재귀(DFS)
- 구별되지만 순서는 정해져 있지 않다 -> 순열, 완전탐색