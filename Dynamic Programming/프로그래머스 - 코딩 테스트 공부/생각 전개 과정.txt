문제)프로그래머스 코딩 테스트 공부

알고력, 코딩력 두 조건이 모두 충족해야 문제를 풀 수 있다.

능력치를 올리려면
1. 공부 -> 시간 당 각 능력치 개별 1상승
2. 문제 풀기 ->
같은 문제를 여러번 풀 수 있고, 모든 문제를 다 풀 필요는 없다.

구할 것: 모든 문제를 풀 수 있는 알고력, 코딩력을 얻기 위한 최단 시간을 구하라

1. 어떤 문제를 먼저 풀도록 만들 것인가?
2. 어떤 전략을 써서 문제를 해결 가능하도록 만들 것인가?

처음에는 문제를 못푸는게 아니구나 상황에 따라 처음부터 풀이 가능한 문제가 있을수도 있음

f(a, c) = a알고력 c코딩력일 때 모든 문제를 풀 수 있는데 걸리는 최단 시간
f(a, c) = min(f(a+1, c) + 1, f(a, c+1) + 1, f(a+a_rwd(i), c+c_rwd(i)) + cost(i))
===> DP로 해결할 수 있다!

시간복잡도: 150(req_alp 최대 크기) * 150(req_cop 최대 크기) * 102(함수 안에 있는 반복문 최대 횟수)

필요한 변수
최단시간 캐시 테이블: Array<IntArray>
alp_rep와 cop_req 최대값
dp 재귀 함수(alp: Int, cop: Int): Int


무한 재귀 호출 발생 가능성
1. (alpReward = 0 && cop >= maxReqCop) || (copReward = 0 && alp >= maxReqAlp)을 만드는 problem을 푸는 경우
2. reward가 모두 0인 문제를 푸는 경우

★★★놓친 케이스★★★
초기 능력치 중 하나 이상이 이미 필요한 능력치보다 크게 주어진 경우
--> IndexOutOfBound 발생

★★★DP를 떠올리게 된 이유 분석★★★
1. 능력치를 올리는 방법은 공부를 하거나 문제를 풀거나이다. 즉, 여러 방법 중 하나를 매번 선택해야 했다 (경우의 수).
2. 능력치는 올리는 방법을 선택할 때마다 정답에 가까워진다. => 이전 상황과 다음 상황 사이에 수적인 관계가 생긴다.
3. 일련의 선택들을 하면 정답 후보 중 하나를 찾을 수 있다. => 경우의 수에 대해 완전 탐색을 하면 반드시 찾을 수 있다.
4. 완전 탐색은 시간이 너무 오래 걸린다. -> DP로 시간을 줄일 수 있을까?
5. 수식을 세워보니 필요한 배열 공간은 max_alp * max_cop, 재귀함수 내 반복문 횟수는 problems.size + 2
   = 150 * 150 * 102 => 시간 내 문제 해결 가능