<백준 10942번 - 펠린드롬?>
문제) 수열이 n개 주어진다. 질문이 m개 주어진다. [i-1, j-1]이 펠린드롬 수열이면 1 아니면 0을 출력하라

출력 개수 = 질문 개수 = m개
질문은 최대 100만개
수열의 길이는 최대 2000

펠린드롬을 확인하는 가장 간단 무식한 방법은 수열 양 끝에서부터 같은 수인지 확인하는 것이다.
1회당 시간복잡도는 N/2 = O(N)이다. 전체 질문에 대한 총 시간복잡도 = O(NM)이다. 시간이 부족하다.
어떻게 시간을 줄이지? DP, 투포인터, 이분탐색이 떠오른다. 이유는 DP는 완전탐색의 시간복잡도를 줄이는
가장 흔하고 강력한 방법이기 때문이고, 투포인터와 이분탐색은 1차원 배열에서 자주 쓰이는 알고리즘이기 때문이다.

f(i,j)를 이전 결과를 바탕으로 구하는 방법이 있을까? 있으면 DP로 해결할 수 있다.
f(i,j) = f(i-1,j-1) * (num[i] == num[j] ? 1 : 0)
미리 답을 다 구해놓고 결과를 출력하는 것이다.
답을 구하는데 걸리는 시간은?
길이(length) 1~n에 대해서 * 왼쪽에서 오른쪽으로 모든 범위를 훑으며 펠린드롬 결과를 저장해야 한다.
 -> O(n * n)

필요한 메모리: 이차원 배열: Array<BooleanArray> - isPelindrom[n][n]
length - [1,n]
start[0, n-length]

초기 설정: isPelindrom[i][i]는 모두 true로 세팅한다.

알고리즘)
1. n을 입력받고 수열을 입력받는다(IntArray)
2. isPelindrom[n][n]을 초기화한다
3. bottom-up 방식으로 isPelindrom[0~n-1][0~n-1] 값을 구한다
4. m을 입력받는다
5. m반복문에서 start,end를 입력받고 { isPelindrom[start-1][end-1] ? 1 : 0 }를 StringBuilder에 저장한다
6. StringBuilder 결과를 출력한다.