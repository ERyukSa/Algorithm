## 날짜
2021-07-03

<br>

## 문제 (2020 카카오 신입 공채)
https://www.acmicpc.net/problem/14502

<br>

## 문제 유형
DFS/BFS + 구현

<br>

## 풀이

<br>

## Code

### 1차

```python
n, m = map(int, input().split())
lab = [list(map(int, input().split())) for _ in range(n)]
temp = [[0] * m for _ in range(n)]

answer = 0

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def case_dfs(count):
    global answer
    
    if count == 3:
        copy_lab()
        
        for i in range(n):
            for j in range(m):
                if temp[i][j] == 2:
                    spread_virus(i, j)

                
        safe_area_cnt = calculate_area()
        
        if safe_area_cnt > answer:
            answer = safe_area_cnt
        return
    
    for i in range(n):
        for j in range(m):
            if lab[i][j] == 0:
                lab[i][j] = 1
                count += 1
                case_dfs(count)
                count -= 1
                lab[i][j] = 0
                
def calculate_area():
    result = 0
    
    for i in range(n):
        for j in range(m):
            if temp[i][j] == 0:
                result += 1
    
    return result

def spread_virus(x, y):  
    for i in range(4):
        tx = x + dx[i]
        ty = y + dy[i]

        if tx < 0 or tx >= n or ty < 0 or ty >= m:
            continue

        if temp[tx][ty] == 0:
            temp[tx][ty] = 2
            spread_virus(tx, ty)
    
def copy_lab():
    for i in range(n):
        for j in range(m):
            temp[i][j] = lab[i][j]
            
case_dfs(0)
print(answer)
```
<br>

### 2차
```python
from collections import deque

def copy_graph():
    global n, m, temp_graph, graph
    
    for i in range(n):
        for j in range(m):
            temp_graph[i][j] = graph[i][j]

            
def spread_virus():
    global temp_graph, n, m, dx, dy
    
    for i in range(n):
        for j in range(m):
            if temp_graph[i][j] == 2:
                temp_graph[i][j] = -1
                
                q = deque()
                q.append((i, j))
                
                while q:
                    x, y = q.popleft()
                    
                    for k in range(4):
                        tx = x + dx[k]
                        ty = y + dy[k]
                        if 0 <= tx < n and 0 <= ty < m and temp_graph[tx][ty] == 0:
                            temp_graph[i][j] = -1
                            q.append((tx, ty))
            
def process(start, cnt):
    global ans, graph, n, m
    
    if cnt == 3:
        copy_graph()
        spread_virus()
        
        temp_answer = 0
        for i in range(n):
            for j in range(m):
                if temp_graph[i][j] == 0:
                    temp_answer += 1
            
        if temp_answer > ans:
            ans = temp_answer
        return 
    
    for i in range(start, n*m):
        r = i // m
        c = i % m
        if graph[r][c] == 0:
            graph[r][c] = 1
            cnt += 1
            process(i+1, cnt)
            graph[r][c] = 0
            cnt -= 1
    

n, m = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(n)]
temp_graph = [[0]*m for _ in range(n)]

ans = 0
dx = [-1, 1, 0 , 0]
dy = [0, 0, -1, 1]

process(0, 0)
print(ans)
```

<br>

## 피드백
