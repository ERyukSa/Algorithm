1. 테스트케이스 개수 입력받는다
2. 노드 개수, 간선 개수, 목적지 후보 개수 입력 받는다
3. 출발 위치, g와 h를 입력받는다
4. 간선을 입력 받는다: start, end, distance
5. 목적지 후보를 입력 받는다

그래프는 연결리스트로 저장한다.
Edge(val noNode: Int, distance: Int)

흠

- 목표: start에서 Edge(g,v,?)를 지나서 end로 가는 경로와 start에서 end로 가는 최단 경로의 길이가 일치하는 end를 모두 출력하라.

- 전략
start -> g -> v -> end
start -> v -> g -> end
둘 중 최단 거리를 구한다.
그것이 start -> end의 최단 거리와 같으면 가능한 도착지이므로 리스트에 추가한다.

1. s에 대해 다익스트라를 돌린다
2. g에 대해 다익스트라를 돌린다
3. v에 대해 다익스트라를 돌린다
그러면 3번의 다익스트라를 수행한다. 목적지 후보 100개에 대해 하는 것보다 빠르다.

- 시간복잡도
다익스트라의 시간복잡도는? 생각이 안나네;; 어케 구하더라
모든 간선을 확인한다. 간선에 대해 연결된 모든 간선을 확인한다??
모든 간선을 확인하고(N), 노드마다 모든 노드로 가는 간선을 가질 수 있으므로(M)
시간복잡도 = O(M * N)
